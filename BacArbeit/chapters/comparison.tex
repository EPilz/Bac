%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Vergleich}
\label{sec:comparison}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=======================================================================
\section{Retrofit}
%=======================================================================
Retrofit ist ein typsicherer HTTP Client für Android und Java, welcher von Square Open Source entwickelt wurde \cite{retrofit}. Das Framework baut auf OkHttp auf, welches die Kommunikation auf der Netzwerkebene übernimmt \cite{okhttp}. Retrofit sagt über sich selbst:

\begin{center}
	\textit{\textquotedblleft Retrofit turns your HTTP API into a Java interface.\textquotedblright}, \cite[Webseite von Retrofit]{retrofit} 
	\\
\end{center}

Mithilfe von Annotation bei den Interface Methoden wird angegeben wie Request zu verarbeiten sind. Daher muss jede Interface-Methode eine HTTP Annotation besitzen, die angibt welche Request Methode zu verwenden ist \cite{retrofit}. Es stehen dabei fünf built-in HTTP Methoden zur Auswahl \texttt{GET}, \texttt{POST}, \texttt{PUT}, \texttt{DELETE} und \texttt{HEAD}.
\\\\
Standardmäßig kann Retrofit nur \texttt{ResponseBody} und \texttt{RequestBody} von OkHttp serialisieren und deserialisieren. Durch das hinzufügen von Konvertern ist es jedoch möglich, weitere Formate wie JSON oder XML zum Übertragen von Daten zu verwenden. Seit der Veröffentlichung von Retrofit in der Version 2, werden auch noch zusätzliche Parser zur Serialisierung und Deserialisierung von JSON-Daten unterstützt. In der Vergangenheit wurde nur die GSON Bibliothek unterstützt, welche daher die häufig verwendetste Bibliothek zum Parsen von JSON-Daten darstellt \cite{consumingRetrofit}. Dadurch wurde die GSON Biliothek auch im Rahmen der Bachelorarbeit zum Übertragen von Daten verwendet.

\subsection{Funktionsweise}
Um Retrofit verwenden zu können, müssen folgende Abhängigkeiten zum Projekt hinzugefügt werden:

\begin{lstlisting}[language=java, caption={app\textbackslash build.gradle},label=dependenciesRetrofit]
dependencies {
	compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
	compile 'com.squareup.retrofit:converter-gson:2.0.0-beta2'
	compile 'com.google.code.gson:gson:2.4'
	compile 'com.squareup.okhttp:okhttp:2.4.0'
}
\end{lstlisting}

Um Requests zur Server Schnittstelle versenden zu können, muss die Retrofit Builder Klasse verwendet werden, welche auch die Basis URL der Server REST-Schnittstelle spezifiziert.

\begin{lstlisting}[language=java, caption={Retrofit Builder},label=retrofitBuilder]
private static final String BASE_URL = "https://revex.inso.tuwien.ac.at/api/";
 
public static <S> S createService(Class<S> serviceClass) {

	Retrofit retrofit = new Retrofit.Builder()
			.baseUrl(BASE_URL)
			.addConverterFactory(GsonConverterFactory.create())
			.build();
	
	return retrofit.create(serviceClass);
}
\end{lstlisting}

Die Endpoints werden durch spezielle Annotationen bei Interface Methoden spezifiziert, die Details über Parameter und die verwendete Request Methode beinhalten. Es stehen unter anderem folgende Annotationen zur Verfügung:

\begin{list}{-}{}
	\item \texttt{@GET}, \texttt{@POST}, \texttt{@PUT}, \texttt{@DELETE}\\
	Diese Annotationen geben an, welche Request Methode zu verwenden ist.
	\item \texttt{@Path} \\
	Durch diese Annotation ist es möglich, die URL des Endpoints dynamisch zu konfigurieren. Dabei wird ein bestimmter Teil in der URL der durch Klammer gekennzeichnet wurde, durch den dazugehörenden Parameter ersetzt (siehe Listing \ref{lst:retrofitPowerPlantService}, Zeile \ref{line:path}).
	\item \texttt{@Body} \\
	Jeder Parameter der über diese Annotation verfügt, wird in den Body der Request Anfrage eingefügt - nachdem das dazugehörende Java Objekt serialisiert wurde (Listing \ref{lst:retrofitPowerPlantService}, Zeile \ref{line:body}).
\end{list}

Der return Wert ist dabei immer ein parametrisiertes \texttt{Call<T>} Objekt, beispielsweise \texttt{Call <PowerPlant>}. Wir kein typenspezifischer Response benötigt oder erwartet, kann als return Wert \texttt{Call<Response>} angegeben werden.
 
\begin{lstlisting}[language=java, caption={Auszug aus dem PowerPlantService},label={lst:retrofitPowerPlantService}, escapechar=|]
public interface PowerPlantService {

	@GET("powerplants")
	public Call<List<PowerPlant>> getPowerPlants();
	
	@POST("powerplants")
	public Call<PowerPlant> createPowerPlant(@Body PowerPlant powerPlant);
	
	@DELETE("powerplants/{id}")
	public Call<PowerPlant> deletePowerPlantById(@Path("id") int id); |\label{line:path}|
	
	@PUT("powerplants/{id}")
	public Call<PowerPlant> updatePowerPlant(@Path("id") int id, @Body PowerPlant powerPlant); |\label{line:body}|
}
\end{lstlisting}

Sollen bei einem Request noch zusätzlich Daten in den Header eingefügt oder dieser manipuliert werden, ist dies durch das Interface \texttt{Interceptor} möglich. Dadurch kann zum Beispiel vor jeder Anfrage an den Server, ein Token hinzugefügt werden, welches angibt ob ein User eingeloggt ist.

\begin{lstlisting}[language=java, caption={Hinzufügen des Tokens, für gültigen Login},label={lst:addToken}, escapechar=|]
public static <S> S createServiceWithAuthToken(Class<S> serviceClass, final AuthToken token) {
	Interceptor interceptor = new Interceptor() {
		@Override
		public Response intercept(Chain chain) throws IOException {
			Request newRequest = chain.request().newBuilder()
				.addHeader("Accept", "application/json")
				.addHeader("X-Auth-Token", token.getToken())
				.build();
		
			return chain.proceed(newRequest);
		}
	};
		
	OkHttpClient client = new OkHttpClient();
	client.interceptors().add(interceptor);
		
	Retrofit retrofit = new Retrofit.Builder()
		.client(client)
		.baseUrl(BASE_URL)
		.addConverterFactory(GsonConverterFactory.create())
		.build();
	
	return retrofit.create(serviceClass);
}
\end{lstlisting}


%=======================================================================
\section{Spring for Android}
%=======================================================================
Spring gliedert sich in zahlreiche Projekte, mit dem Ziel Java Entwicklung zu vereinfachen. Die Idee zum Spring Framework hatte Rod Johnson im Jahr 2003. An den zahlreichen Open Source Projekten von Spring  beteiligen sich weltweit eine große Anzahl von Entwicklern \cite{springITWissen}. Spring for Android ist ein Projekt von Spring, dass die Entwicklung von Andorid-Apps vereinfachen soll. Es stellt dabei ausgewählte Komponenten von Spring, gebündelt für Android zur Verfügung \cite{springForAndroid:website}. Das sind im speziellen 

\begin{itemize}
	\item ein Rest Client (RestTemplate) und
	\item Authentifikation Unterstützung für Security APIs (OAuth).
\end{itemize}

Spring for Android unterstützt dabei nicht Dependency Injection, eine der Kernfunktionen des Core Spring Frameworks. Es ist daher nicht möglich Inversion of Control auf Android Plattformen zu verwenden \cite{springForAndroid:dahanne}.
\\\\
Grundbaustein des Frameworks ist die Klasse \texttt{RestTemplate}, welche Teil des im Jahr 2009 erschienen Frameworks "Spring for MVC" ist. Diese Klasse ermögliche Java-Entwicklern eine High-Level-Abstraktion von untergeordneten Java-APIs, wie HTTP Clients. \texttt{RestTemplate} for Android unterstützt dabei auch die gzip Komprimierung und die Übertragung von JSON und XML Daten, indem POJO Objekte automatisiert umgewandelt werden \cite{springForAndroid:dahanne}.

\subsection{Funktionsweise}
Um Spring for Android verwenden zu können, muss folgende Abhängigkeit zum Projekt hinzugefügt werden:

\begin{lstlisting}[language=java, caption={app\textbackslash build.gradle},label=dependenciesSpring for Android]
dependencies {
	compile 'org.springframework.android:spring-android-rest-template:2.0.0.M1'
}
\end{lstlisting}

Mithilfe der Klasse \texttt{RestTemplate} werden HTTP Anfragen zusammengebaut, um mit der Server REST-Schnittstelle kommunizieren zu können.

\begin{lstlisting}[language=java, caption={Anfrage um alle Kraftwerke zu erhalten},label={lst:getAllPowerPlants}, escapechar=|]
public static List<PowerPlant> getPowerPlants() {
  RestTemplate restTemplate = new RestTemplate(new BufferingClientHttpRequestFactory(new SimpleClientHttpRequestFactory()));
  restTemplate.getMessageConverters().add(new MappingJackson2HttpMessageConverter());
 
 URI url = UriComponentsBuilder.fromUriString(ServiceGenerator.BASE_URL)
 .path("/powerplants").build().toUri();
 
 HttpHeaders headers = new HttpHeaders();
 headers.set("X-Auth-Token", UtilitiesManager.getInstance().getAuthToken().getToken());
 headers.setContentType(MediaType.APPLICATION_JSON);
 
 HttpEntity entity = new HttpEntity(headers);
 
 HttpEntity<PowerPlant[]> response = restTemplate.exchange(url, HttpMethod.GET, entity, PowerPlant[].class);
 
 return Arrays.asList(response.getBody());
}

\end{lstlisting}

Die Klasse \texttt{RestTemplate} ist dabei das Kernstück für den clientseitigen Zugriff auf einen RESTful Service. Das Verhalten kann durch Callback Methoden und durch konfigurieren des \texttt{HttpMessageConverter} angepasst werden. Der \texttt{HttpMessageConverter} wird dabei verwendet um einen HTTP Request Body zu erstellen oder den Response in Java Objekte zu konvertieren. Die Klasse \texttt{MappingJackson2HttpMessageConverter} ist ein Message Converter mit dem JSON Daten verarbeitet werden können.

\texttt{RestTemplate} stellt verschiedene Methoden zur Verfügung, um die zugrundeliegenden HTTP Methoden verwenden zu können. Diese sind unter anderem \texttt{DELETE}, \texttt{GET}, \texttt{HEAD}, \texttt{OPTIONS}, \texttt{POST} and \texttt{PUT} \cite{springDokuRestTemplate}.c


%=======================================================================
\section{Jersey}
%=======================================================================
In Java gibt es mit JAX-RS einen Standard zum Implementieren von REST-basierten Webservices. Dieser wurde in der JSR-311 "JAX-RS: The Java API for RESTful Web Services" \cite{jsr311} genauer spezifiziert und ist deshalb ein offizieller Teil von Java. Das Jersey Framework ist dabei eine robuste Open-Source Referenz Implementierung der Spezifikation \cite{restfulWS:Kubert}.


