%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Frameworks}
\label{sec:comparison}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=======================================================================
\section{Retrofit}
%=======================================================================

\subsection{Allgemein}
Retrofit ist ein typsicherer HTTP Client für Android und Java, welcher von Square Open Source entwickelt wurde \cite{retrofit}. Das Framework baut auf OkHttp auf, welches die Kommunikation auf der Netzwerkebene übernimmt \cite{okhttp}. Retrofit sagt über sich selbst:

\begin{center}
	\textit{\textquotedblleft Retrofit turns your HTTP API into a Java interface.\textquotedblright}, \cite[Webseite von Retrofit]{retrofit} 
	\\
\end{center}

Mithilfe von Annotation bei den Interface Methoden wird angegeben wie Request zu verarbeiten sind. Daher muss jede Interface-Methode eine HTTP Annotation besitzen, die angibt welche Request Methode zu verwenden ist \cite{retrofit}. Es stehen dabei fünf built-in HTTP Methoden zur Auswahl \texttt{GET}, \texttt{POST}, \texttt{PUT}, \texttt{DELETE} und \texttt{HEAD}.
\\\\
Standardmäßig kann Retrofit nur \texttt{ResponseBody} und \texttt{RequestBody} von OkHttp serialisieren und deserialisieren. Durch das hinzufügen von Konvertern ist es jedoch möglich, weitere Formate wie JSON oder XML zum Übertragen von Daten zu verwenden. Seit der Veröffentlichung von Retrofit in der Version 2, werden auch noch zusätzliche Parser zur Serialisierung und Deserialisierung von JSON-Daten unterstützt. In der Vergangenheit wurde nur die GSON Bibliothek unterstützt, welche daher die häufig verwendetste Bibliothek zum Parsen von JSON-Daten darstellt \cite{consumingRetrofit}. Dadurch wurde die GSON Biliothek auch im Rahmen der Bachelorarbeit zum Übertragen von Daten verwendet.

\subsection{Funktionsweise}
Um Retrofit verwenden zu können, müssen folgende Abhängigkeiten zum Projekt hinzugefügt werden:

\begin{lstlisting}[language=java, caption={app\textbackslash build.gradle},label=dependenciesRetrofit]
dependencies {
	compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
	compile 'com.squareup.retrofit:converter-gson:2.0.0-beta2'
	compile 'com.google.code.gson:gson:2.4'
	compile 'com.squareup.okhttp:okhttp:2.4.0'
}
\end{lstlisting}

Um Requests zur Server Schnittstelle versenden zu können, muss die Retrofit Builder Klasse verwendet werden, welche auch die Basis URL der Server REST-Schnittstelle spezifiziert.

\begin{lstlisting}[language=java, caption={Retrofit Builder},label=retrofitBuilder]
private static final String BASE_URL = "https://revex.inso.tuwien.ac.at/api/";
 
public static <S> S createService(Class<S> serviceClass) {

	Retrofit retrofit = new Retrofit.Builder()
			.baseUrl(BASE_URL)
			.addConverterFactory(GsonConverterFactory.create())
			.build();
	
	return retrofit.create(serviceClass);
}
\end{lstlisting}

Die Endpoints werden durch spezielle Annotationen bei Interface Methoden spezifiziert, die Details über Parameter und die verwendete Request Methode beinhalten. Es stehen unter anderem folgende Annotationen zur Verfügung:

\begin{list}{-}{}
	\item \texttt{@GET}, \texttt{@POST}, \texttt{@PUT}, \texttt{@DELETE}\\
	Diese Annotationen geben an, welche Request Methode zu verwenden ist.
	\item \texttt{@Path} \\
	Durch diese Annotation ist es möglich, die URL des Endpoints dynamisch zu konfigurieren. Dabei wird ein bestimmter Teil in der URL der durch Klammer gekennzeichnet wurde, durch den dazugehörenden Parameter ersetzt (siehe Listing \ref{lst:retrofitPowerPlantService}, Zeile \ref{line:path}).
	\item \texttt{@Body} \\
	Jeder Parameter der über diese Annotation verfügt, wird in den Body der Request Anfrage eingefügt - nachdem das dazugehörende Java Objekt serialisiert wurde (Listing \ref{lst:retrofitPowerPlantService}, Zeile \ref{line:body}).
\end{list}

Der return Wert ist dabei immer ein parametrisiertes \texttt{Call<T>} Objekt, beispielsweise \texttt{Call <PowerPlant>}. Wir kein typenspezifischer Response benötigt oder erwartet, kann als return Wert \texttt{Call<Response>} angegeben werden.
 
\begin{lstlisting}[language=java, caption={Auszug aus dem PowerPlantService},label={lst:retrofitPowerPlantService}, escapechar=|]
public interface PowerPlantService {

	@GET("powerplants")
	public Call<List<PowerPlant>> getPowerPlants();
	
	@POST("powerplants")
	public Call<PowerPlant> createPowerPlant(@Body PowerPlant powerPlant);
	
	@DELETE("powerplants/{id}")
	public Call<PowerPlant> deletePowerPlantById(@Path("id") int id); |\label{line:path}|
	
	@PUT("powerplants/{id}")
	public Call<PowerPlant> updatePowerPlant(@Path("id") int id, @Body PowerPlant powerPlant); |\label{line:body}|
}
\end{lstlisting}

Sollen bei einem Request noch zusätzlich Daten in den Header eingefügt oder dieser manipuliert werden, ist dies durch das Interface \texttt{Interceptor} möglich. Dadurch kann zum Beispiel vor jeder Anfrage an den Server, ein Token hinzugefügt werden, welches angibt ob ein User eingeloggt ist.

\begin{lstlisting}[language=java, caption={Hinzufügen des Tokens, für gültigen Login},label={lst:addToken}, escapechar=|]
public static <S> S createServiceWithAuthToken(Class<S> serviceClass, final AuthToken token) {
	Interceptor interceptor = new Interceptor() {
		@Override
		public Response intercept(Chain chain) throws IOException {
			Request newRequest = chain.request().newBuilder()
				.addHeader("Accept", "application/json")
				.addHeader("X-Auth-Token", token.getToken())
				.build();
		
			return chain.proceed(newRequest);
		}
	};
		
	OkHttpClient client = new OkHttpClient();
	client.interceptors().add(interceptor);
		
	Retrofit retrofit = new Retrofit.Builder()
		.client(client)
		.baseUrl(BASE_URL)
		.addConverterFactory(GsonConverterFactory.create())
		.build();
	
	return retrofit.create(serviceClass);
}
\end{lstlisting}


%=======================================================================
\section{Spring for Android}
%=======================================================================

\subsection{Allgemein}
Spring gliedert sich in zahlreiche Projekte, mit dem Ziel Java Entwicklung zu vereinfachen. Die Idee zum Spring Framework hatte Rod Johnson im Jahr 2003. An den zahlreichen Open Source Projekten von Spring  beteiligen sich weltweit eine große Anzahl von Entwicklern \cite{springITWissen}. Spring for Android ist ein Projekt von Spring, dass die Entwicklung von Andorid-Apps vereinfachen soll. Es stellt dabei ausgewählte Komponenten von Spring, gebündelt für Android zur Verfügung \cite{springForAndroid:website}. Dies sind im speziellen 

\begin{itemize}
	\item ein Rest Client (RestTemplate) und
	\item Authentifikation Unterstützung für Security APIs (OAuth).
\end{itemize}

Spring for Android unterstützt dabei nicht, Dependency Injection, eine der Kernfunktionen des Core Spring Frameworks. Es ist daher nicht möglich Inversion of Control auf Android Plattformen zu verwenden \cite{springForAndroid:dahanne}.
\\\\
Grundbaustein des Frameworks ist die Klasse \texttt{RestTemplate}, welche Teil des im Jahr 2009 erschienen Framework \textquotedblleft Spring for MVC\textquotedblright ist. Diese Klasse ermögliche Java-Entwicklern eine High-Level-Abstraktion von untergeordneten Java-APIs, wie HTTP Clients. \texttt{RestTemplate} for Android unterstützt dabei auch die gzip Komprimierung und die Übertragung von JSON und XML Daten, indem POJO Objekte automatisiert umgewandelt werden \cite{springForAndroid:dahanne}.

\subsection{Funktionsweise}
Um Spring for Android verwenden zu können, muss folgende Abhängigkeit zum Projekt hinzugefügt werden:

\begin{lstlisting}[language=java, caption={app\textbackslash build.gradle},label=dependenciesSpring for Android]
dependencies {
	compile 'org.springframework.android:spring-android-rest-template:2.0.0.M1'
}
\end{lstlisting}

Mithilfe der Klasse \texttt{RestTemplate} werden HTTP Anfragen zusammengebaut, um mit der Server REST-Schnittstelle kommunizieren zu können.

\begin{lstlisting}[language=java, caption={Anfrage um alle Kraftwerke zu erhalten},label={lst:getAllPowerPlants}, escapechar=|]
public static List<PowerPlant> getPowerPlants() {
  RestTemplate restTemplate = new RestTemplate(new BufferingClientHttpRequestFactory(new SimpleClientHttpRequestFactory()));
  restTemplate.getMessageConverters().add(new MappingJackson2HttpMessageConverter());
 
 URI url = UriComponentsBuilder.fromUriString(ServiceGenerator.BASE_URL)
 .path("/powerplants").build().toUri();
 
 HttpHeaders headers = new HttpHeaders();
 headers.set("X-Auth-Token", UtilitiesManager.getInstance().getAuthToken().getToken());
 headers.setContentType(MediaType.APPLICATION_JSON);
 
 HttpEntity entity = new HttpEntity(headers);
 
 HttpEntity<PowerPlant[]> response = restTemplate.exchange(url, HttpMethod.GET, entity, PowerPlant[].class);
 
 return Arrays.asList(response.getBody());
}
\end{lstlisting}

Die Klasse \texttt{RestTemplate} ist dabei das Kernstück für den clientseitigen Zugriff auf einen RESTful Service. Das Verhalten kann durch Callback Methoden und durch konfigurieren des \texttt{HttpMessageConverter} angepasst werden. Der \texttt{HttpMessageConverter} wird dabei verwendet um einen HTTP Request Body zu erstellen oder den Response in Java Objekte zu konvertieren. Die Klasse \texttt{MappingJackson2HttpMessageConverter} ist ein Message Converter mit dem JSON Daten verarbeitet werden können.

\texttt{RestTemplate} stellt verschiedene Methoden zur Verfügung, um die zugrundeliegenden HTTP Methoden verwenden zu können. Diese sind unter anderem \texttt{DELETE}, \texttt{GET}, \texttt{HEAD}, \texttt{OPTIONS}, \texttt{POST} and \texttt{PUT} \cite{springDokuRestTemplate}.


%=======================================================================
\section{Jersey}
%=======================================================================

\subsection{Allgemein}
In Java gibt es mit JAX-RS einen Standard zum Implementieren von REST-basierten Webservices. Dieser wurde in der JSR-311 "JAX-RS: The Java API for RESTful Web Services" \cite{jsr311} genauer spezifiziert und ist deshalb ein offizieller Teil von Java. Das Jersey Framework ist dabei eine robuste Open-Source Referenz Implementierung der Spezifikation \cite{restfulWS:Kubert}.
\\\\
Die JAX-RS-Client-API Implementierung von Jersey kann mit eine beliebige Web-Service, der auf das HTTP-Protokoll aufsetzt, kommunizieren. Der serverseitige Endpoint muss nicht unbedingt mit JAX-RS implementiert sein.
\\\\
Den Grundbaustein der Jersey-Client Implementierung bildet die Klasse \texttt{ClientBuilder}. Diese wird dazu verwendet neue \texttt{Client}-Instanzen anzulegen, über welche Requests zum Server versendet werden. Mithilfe der \texttt{ClientBuilder}-Klasse können auch zusätzliche Eigenschaften für den \texttt{Client} definiert werden, wie zum Beispiel die SSL Transport Konfiguration. Des weiteren kann ein \texttt{Client} mithilfe der \texttt{ClientConfig}-Klasse speziell konfiguriert werden, diese Konfiguration wird bei der Erstellung des \texttt{Client} einer Factory Methode übergeben. Mithilfe der \texttt{ClientConfig}-Klasse können Provider registriert oder Filter hinzugefügt werden. Ein oft verwendeter Filter ist zum Beispiel der \texttt{LoggingFilter}. Dieser ist ein Protokollierungsfilter, der die Kommunikation zwischen Server und Client aufzeichnet und dessen Aufzeichnung später für Debugging Zwecke genutzt werden kann \cite{jersey:doku}. 
\\\\
Nachdem eine \texttt{Client}-Instanz erfolgreich erstellt wurde, kann mit dieser Instanz ein \texttt{WebTarget} Objekt erzeugt werden, welches den Endpoint zum Server spezifiziert. Um nun erfolgreich einen HTTP Request abzusetzen, muss ein \texttt{Invocation.Builder} Objekt erzeugt werden. Dieses Objekt wird dazu genutzt um die Anfrage zum Server genauer zu konfigurieren und abzusenden. Es gibt sowohl Methoden um den Media Type des Request und Response anzugeben, die HTTP Methode zu definieren und den HTTP Header genauer zu spezifizieren \cite{jersey:doku}.
\\\\
Die Client API von Jersey unterstützt alle gängigen HTTP Methoden, welche \texttt{GET}, \texttt{POST}, \texttt{PUT}, \texttt{DELETE}, \texttt{HEAD} und \texttt{OPTION} sind \cite{invocation:api}.

\subsection{Workaround für Android}
Jersey kann erst ab der Version 2.16 auf Android verwendet werden. Davor war es nicht möglich Jersey auf Android auszuführen, aufgrund der Abhängigkeit des Client Core Moduls zum package \texttt{javax.xml.stream}, welches in der Android Java API nicht vorkommt. In der neuen Jersey Version wurden alle JAXB-B Provider Abhängigkeiten in ein eigenes Modul ausgelagert \cite{jerseyAndroid:podlesak}. Fügt man nun die Abhängigkeit zu diesem Modul in das Projekt ein, funktioniert die grundlegende Kommunikation zwischen einem Android Jersey Client und den REST Server. 

\begin{lstlisting}[language=java, caption={JAXB-B Dependency in der bulid.grade Datei}]
compile 'javax.xml.bind:jaxb-api:2.1'
\end{lstlisting}
 
Dennoch ist es noch immer nicht möglich, den Jersey Client ohne Fehler in einer Android Umgebung zu verwenden. Es werden noch immer Abhängigkeiten zu packages benötigt, die in der Android-Umgebung nicht verfügbar sind. Mithilfe der HK2 API ist es möglich Komponenten ohne Vorbereitung aus dem HK2 Service Locator zu entfernen. Der folgende Workaround hilft die geworfenen Fehler durch fehlenden Abhängigkeiten zu unterdrücken und dennoch alle Funktionen des Jersey Clients in der Android Umgebung zu unterstützen \cite{jerseyAndroid2:podlesak}.

\begin{lstlisting}[language=java, caption={Workaround Jersey Client auf Android},label={lst:jerseyAndroid }, escapechar=|]
public static class AndroidFriendlyFeature implements Feature {
	
	@Override
	public boolean configure(FeatureContext context) {
		context.register(new AbstractBinder() {
		
			@Override
			protected void configure() {
				addUnbindFilter(new Filter() {
				
					@Override
					public boolean matches(Descriptor d) {
					  String implClass = d.getImplementation();
					  return implClass.startsWith(
						"org.glassfish.jersey.message.internal.DataSource")
						|| implClass.startsWith(
					   "org.glassfish.jersey.message.internal.RenderedImage");
					}
				});
			}
		});
		return true;
	}
}
\end{lstlisting}

Das Feature für den Workaround muss später noch bei der \texttt{Client}-Instanz registriert werden.

\begin{lstlisting}[language=java, caption={Feature registrieren}]
client = ClientBuilder.newClient().
							register(AndroidFriendlyFeature.class);
\end{lstlisting}


\subsection{Funktionsweise}
Hat man alle erforderlichen Abhängigkeiten zum Projekt hinzugefügt, kann durch folgenden Implementierung ein einfacher \texttt{GET} Request realisiert werden, der ein \texttt{PowerPlant} Objekt zurückgibt. Der Media Type wird mithilfe der \texttt{accept}-Methode spezifiziert, die Art der HTTP Request Methode wird durch \texttt{get(PowerPlant.class)} angegeben. Dabei wird durch den Parameter in der Methode der Returntyp des Response festgelegt, in diesem Fall wird genau ein Objekt des Typs \texttt{PowerPlant} erwartet. 

\begin{lstlisting}[language=java, caption={GET Request},label={lst:jerseyGET}, escapechar=|]

public static PowerPlant getPowerPlantById(int id) {
	ClientConfig clientConfig = new ClientConfig().
					register(JacksonFeature.class);
	
	Client client = ClientBuilder.newClient(clientConfig).
					register(AndroidFriendlyFeature.class);
	
	Invocation.Builder builder = client.target(BASE_URL).path("/powerplants/" + id).request(MediaType.APPLICATION_JSON);
	
	PowerPlant powerPlant = builder.accept(MediaType.APPLICATION_JSON).get(PowerPlant.class);
	
	return powerPlant;
}
\end{lstlisting}

Im folgenden Beispiel wird ein \texttt{POST} Request abgesendet, der ein Objekt an den Server im JSON Format übergibt und auch einen Returnwert im JSON Format erwartet. 
\begin{lstlisting}[language=java, caption={POST Request},label={lst:jerseyPOST}, escapechar=|]

PowerPlant newPowerPlant = builder.
			accept(MediaType.APPLICATION_JSON).
			post(Entity.entity(powerPlant, MediaType.APPLICATION_JSON), 
					PowerPlant.class);

\end{lstlisting}


